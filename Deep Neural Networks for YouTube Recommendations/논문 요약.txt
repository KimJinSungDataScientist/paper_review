기존 recommendation은 
작은 규모 알고리즘에만 적합함

기본데이터가 없으면(잘 정의되어 있지
않으면) 제대로 구성하지 못함

tensorflow 기반의 google brain사용
10억개 파라미터, 수천억개 examples

추천시스템을 위한 딥러닝은 거의 없음

1번째 뉴럴네트워크
유튜브 활동 기록
작은 subset(수백여개) 거대한 corpus에서

user와 비디오를 설명하는 파라미터를
사용해 각 비디오의 순위를 지정

사용자 U와 컨텍스트 C를 
기반으로 한 말뭉치V의 수백만 
개의 비디오(클래스) 중에서 
예측 문제가 특정 시간대에 정확하게 
달라지는 극단적인 다중 클래스 
클래스로서 권고안을 제시한다.

u R^n는 사용자 고차원
v R^n는 candidate video 고차원


softmax 사용

수백만개 클래스를 효율적으로
학습시키기 위해
negative classes 샘플링 기술 사용

이 기법을 사용함으로서,
기존 소프트맥스에 비해 100배이상의
속도 향상

비계층적 소프트-맥스, 트리의 각
 노드를 가로지르는 것은 종종 관련이
 없는 클래스 세트 간의 차별화를 
포함하며, 분류 문제를 훨씬 더 어렵고
 성능 저하로 만든다.

nns algorithm

사용자의 시청 기록은 
임베딩을 통해 벡터 표현에
 매핑되는 희소 비디오 ID의
 가변 길이 시퀀스로 표현된다.

7개 전략중 가장 잘 수행된 임베딩의
평균 구함

첫번째 넓은층
몇가지 층의 layer들 fully connected
로 연결됨(relu 사용)

검색기록은 시청기록과 유사하게 처리됨
각 쿼리는 유니그램과 빅그램으로
토큰화되고 각 토큰이 내장됨
평균이 되면 사용자의 토큰화된
 Em-bed 쿼리는 요약된
 고밀도 검색 기록을 나타냅니다.

정규화된 데이터(성별, 로그인상태,
연령 등등)들은 0과1로 즉시 입력됨

train set은 우리가 만든 권장사항만
이 아니라, 모든 유튜브 시청기록과
다른 사이트 시청기록도 포함

이렇게 안하면 새로운 내용이 표면에
올라오기 힘들기 때문


만약 사용자가 우리가 만든 루트가 아닌
다른경로로 시청시 해당 경로를
다른 사용자에게도 빠르게 전파 해야됨

손실함수를 통해 지나치게 활동적인
사용자가 시스템에 큰영향을 끼치는것을
방지

만약 테일러스위프트 검색시
검색결과에 나오는거가
가장 시청 가능성이 높다고 판단함

하지만 마지막 시청기록으로 추후
사용자의 페이지에서 추천을
해주었지만, 낮은 성과를 보임

무작위로 보류된 시청기록을 예측하는 것보다
것보다 다음 보게 될 것을 예측하는게
성능이 더 좋았다.




